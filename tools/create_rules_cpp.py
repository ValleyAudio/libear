#!/bin/python
import numpy as np
import ear.core.direct_speakers.panner
from jinja2 import Template


def rule_to_row(rule):
    possible_gains = [
        (1.0, "1.0"),
        (0.0, "0.0"),
        (np.sqrt(1 / 2), "std::sqrt(1.0 / 2.0)"),
        (np.sqrt(1 / 3), "std::sqrt(1.0 / 3.0)"),
        (np.sqrt(2 / 3), "std::sqrt(2.0 / 3.0)"),
        (np.sqrt(1 / 4), "std::sqrt(1.0 / 4.0)"),
        (np.sqrt(3 / 4), "std::sqrt(3.0 / 4.0)"),
    ]

    def get_gain_str(gain):
        for poss_gain, gain_str in possible_gains:
            if abs(poss_gain - gain) < 1e-10:
                return gain_str

        assert False

    gains_str = ", ".join(
        '{{"{label}", {gain}}}'.format(label=label, gain=get_gain_str(gain))
        for label, gain in rule.gains
    )

    return '{{"{speakerLabel}", {{{gains}}}, {{{input_layouts}}}, {{{output_layouts}}}}}'.format(
        speakerLabel=rule.speakerLabel,
        gains=gains_str,
        input_layouts=", ".join('"{}"'.format(l) for l in rule.input_layouts)
        if rule.input_layouts is not None
        else "",
        output_layouts=", ".join('"{}"'.format(l) for l in rule.output_layouts)
        if rule.output_layouts is not None
        else "",
    )


template = Template(
    """
// generated by:
//     python tools/create_rules_cpp.py | clang-format -style=file
// perhaps edit that instead?

#include "ear/direct_speakers/mapping_rules.hpp"
#include <cmath>

namespace ear {
  const std::vector<MappingRule> rules = {
    {% for rule in rules -%}
        {{rule_to_row(rule)}},
    {% endfor -%}
  };
  const std::map<std::string, std::string> itu_packs = {
    {% for pack, layout in itu_packs.items() -%}
        {"{{pack}}", "{{layout}}"},
    {% endfor -%}
  };
}
""".strip()
)

print(
    template.render(
        rules=ear.core.direct_speakers.panner.rules,
        itu_packs=ear.core.direct_speakers.panner.itu_packs,
        rule_to_row=rule_to_row,
    )
)
